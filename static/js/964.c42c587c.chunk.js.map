{"version":3,"file":"static/js/964.c42c587c.chunk.js","mappings":"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","sources":["../../kooljs/worker_utils.js","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../../kooljs/worker.js"],"sourcesContent":["// Copyright (c) 2025 Ji-Podhead and Project Contributors\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n// 1. All commercial uses of the Software must:\n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).\n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nvar type,trigger,newtriggers\nvar group,distance, duration;\nclass Worker_Utils{\n\n\n/**\n * Adds a trigger to the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, it is created.\n * If the trigger does exist, the target is added to the existing trigger.\n * @param {number} id - The id of the animation to add the trigger to.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\n addTrigger({id, target, step, time}) {\n    if (this.trigger_registry.get(id) == undefined) {\n        this.trigger_registry.set(id, new Map());\n    }\n    if (this.trigger_registry.get(id).get(step) == undefined) {\n        this.trigger_registry.get(id).set(step, new Map());\n        this.trigger_registry\n            .get(id)\n            .get(step)\n            .set(time, new Uint8Array([target]));\n    } else if (this.trigger_registry.get(id).get(step).get(time) == undefined) {\n        this.trigger_registry\n            .get(id)\n            .get(step)\n            .set(time, new Uint8Array([target]));\n    } else {\n        trigger = this.trigger_registry.get(id).get(step).get(time);\n        if (trigger.includes(target) == false) {\n             newtriggers = new Array(trigger);\n            newtriggers.push(target);\n            newtriggers = new Uint8Array(newtriggers);\n            this.trigger_registry.get(id).get(step).set(time, newtriggers);\n        } else {\n            console.warn(\n                `trigger already exists: target ${target} in timeframe ${time} in step ${step} on animation with id ${id}`\n            );\n        }\n    }\n}\n/**\n * Removes a trigger from the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, a warning is printed.\n * If the trigger does exist, the target is removed from the existing trigger.\n * If the trigger is empty after removal (i.e. it only contained the target), the trigger is removed.\n * @param {number} id - The id of the animation to remove the trigger from.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\n removeTrigger({id, target, step, time}) {\n    trigger = this.trigger_registry.get(id).get(step)\n    if (trigger != undefined) {\n        if (trigger.get(time) != undefined) {\n            trigger = trigger.get(time);\n        } else {\n            return console.warn(\n                \"the slected timeframe in the  step does not include the target\"\n            );\n        }\n    } else {\n        return console.warn(\"the trigger registr has does not include the step\");\n    }\n    const targetId = trigger.indexOf(target);\n    if (targetId != undefined && trigger.length > 1) {\n        const newtriggers = new Uint8Array(new Array(trigger).splice(targetId, 1));\n        console.log(\n            `removed trigger target ${target} in timeframe ${time} in step ${step} from from id ${id}`\n        );\n        this.trigger_registry.get(id).get(step).set(time, newtriggers);\n    } else {\n        this.trigger_registry.get(id).get(step).set(time, undefined);\n    }\n    // else{\n    //     this.trigger_registry.get(id).set(step,undefined)\n    // }\n}\n update(type, values) {\n    values.map((x) => {\n        if (this.sequence_registry.lengths[x.id] != x.values.length - 1) {\n            if (this.lerp_registry.loop[x.id] == 1) {\n                this.removeTrigger(\n                   {id:x.id,\n                    target:x.id,\n                    step:this.sequence_registry.lengths[x.id] - 1,\n                    time:this.lerp_registry.duration[x.id]}\n                );\n                this.addTrigger(\n                    {\n                    id:x.id,\n                    target:x.id,\n                    step:x.values.length - 2,\n                    time:this.lerp_registry.duration[x.id]}\n                );\n                //this.trigger_registry.get(x.id).set(lerpChain_registry.lengths[x.id]-1,undefined)\n            }\n            this.sequence_registry.lengths[x.id] = x.values.length - 1;\n        }\n        if (type == 2) {\n            x.values.map((val, i) => {\n                this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[x.id] + i] =\n                    val;\n            });\n        } else if (type == 3) {\n            x.values.map((val, i) => {\n                this.sequence_registry.matrix_sequences.get(x.id).set(i, val);\n            });\n        }\n        this.sequence_registry.reset(x.id);\n    });\n}\n\n/**\n * Calls a lambda  stored in callback_map with the given id and arguments.\n * @param {number} id - The id of the lambda  to call\n * @param {any[]} args - The arguments to pass to the lambda \n */\n lambda_call(id, args) {\n    try {\n        // console.log(args)\n        // console.log(id)\n        return this.callback_map.get(id)(args);\n    } catch (err) {\n        console.error(\"error in lambda call\", id);\n        console.error(this.callback_map.get(id));\n        console.error(err);\n    }\n}\n// ----------------------------------------> EVENTS <--\n\n\n start_loop() {\n    if (this.loop_resolver == null) {\n        this.animateLoop();\n    }\n}\nstop_loop() {\n    if (this.loop_resolver != null) {\n        this.loop_resolver.abort();\n        this.loop_resolver = null;\n    }\n}\n/**\n * starts a list of animations\n * @param {Array<number>} indices an array of ids of the animations to start\n */\n  start_animations(indices) {\n    indices.map((id) => {\n        this.lerp_registry.delete_group_member(id)\n        this.sequence_registry.soft_reset(id);\n    });\n    this.start_loop();\n}\n/**\n * stops a list of animations\n * @param {Array<number>|string} indices an array of ids of the animations to stop; if \"all\", stops all animations\n */\n\n  stop_animations(indices) {\n    if (indices === \"all\") {\n        this.lerp_registry.stop_all();\n        this.stop_loop();\n    }\n    else {\n        indices.map((id) => {\n            this.lerp_registry.deactivate(id);\n        });\n    \n    if (this.lerp_registry.active_numbers.length == 0&&\n        this.lerp_registry.active_timelines.size == 0&&\n        this.lerp_registry.active_matrices.size == 0&&\n        this.lerp_registry.active_groups.size == 0\n    ) {\n        this.stop_loop();\n    }\n}\n}\n/**\n * Resets a list of animations.\n *\n * If \"all\" is passed, stops the animation loop and resets all active animations.\n * Otherwise, resets each animation in the provided indices, re-activates it, and\n * updates the results based on its type. If any animations were stopped and reset,\n * a render message is posted with the updated results.\n *\n * @param {Array<number>|string} indices - An array of animation IDs to reset, or \"all\" to reset all animations.\n */\n\n    reset_animations(indices) {\n    if (indices == \"all\") {\n        if(this.sequence_registry!=undefined){this.sequence_registry.stop_loop()}\n        else {this.stop_loop()}\n        indices = this.lerp_registry.type.map((t,i)=>{return i});\n    }\n    //stop_animations(indices)\n    var stopped=0\n    const results={ \n        number_results: new Map(),\n        matrix_results: new Map(),\n    }\n    //this.sequence_registry.hard_reset(indices);\n    indices.map((x) => {\n        this.sequence_registry.reset(x);\n        this.lerp_registry.activate(x);\n            \n            switch (this.lerp_registry.type[x]) {\n                case 2:\n                    results.number_results.set(x,this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[x]])\n                    stopped+=1\n                    break;\n                case 3:\n                        results.matrix_results.set(\n                            x,\n                            this.sequence_registry.matrix_sequences.get(x).get(0)\n                        );\n                        stopped+=1\n                    break;\n                default:\n                    break;\n            }\n    });\n    if ( this.loop_resolver == null&&stopped> 0)\n        postMessage({\n            message: \"render\",\n            number_results: results.number_results,\n            matrix_results: results.matrix_results,\n        });\n}\n/**\n * Changes the framerate of the animation loop.\n *\n * @param {number} fps_new - The new framerate in frames per second.\n */\n  change_framerate(fps_new) {\n    this.fps = fps_new;\n}\n/**\n * This  can be called by the worker when a constant value is changed.\n * The main thread will receive a message with the changed value.\n * @param {number} id - the id of the constant\n * @param {number} type - the type of the constant (0 = number, 1 = matrix)\n */\n  render_constant(id, type) {\n    postMessage({\n        message: \"render_constant\",\n        id: id,\n        type: type,\n        value: get_constant(id, type),\n    });\n}\n\n// ----------------------------------------> User API <--\n\n/**\n * Sets a Lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number} value - the value to set\n */\n setLerp(index, step, value) {\n    //console.log(lerpChain_registry.buffer[this.lerp_registry.lerp_chain_start[index]+step])\n    this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[index] + step] =\n        value;\n}\n/**\n * Sets the matrix lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number[]} value - the matrix to set. The matrix is a 1 dimensional array of floats with a length that is a multiple of 4 (e.g. [r1, g1, b1, a1, r2, g2, b2, a2])\n */\n setMatrix(index, step, value) {\n    try{\n    value.map((x, i) => {\n        this.sequence_registry.matrix_sequences.get(index).get(step)[i] = x;\n    });\n    }\n    catch(err){\n        console.error(` error in setMatrix:\n            ${err}`\n        )\n    }\n}\n/**\n * Updates a constant value.\n * @param {number} id - the id of the constant to update\n * @param {string} type - the type of the constant (number or matrix)\n * @param {number | number[]} value - the new value of the constant\n */\n update_constant(id, type, value) {\n    this.constant_registry.update(type, id, value);\n}\n/**\n * Gets a constant value.\n * @param {number} id - the id of the constant\n * @param {string} type - the type of the constant (number or matrix)\n * @returns {number | number[]} value - the value of the constant\n */\n get_constant(id, type) {\n    return this.constant_registry.get(type, id);\n}\n/**\n * Gets the current progress of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current progress value of the animation.\n */\n get_time(id) {\n    return this.lerp_registry.progress[id];\n}\n/**\n * Checks if an animation is currently running.\n * @param {number} id - The identifier for the animation.\n * @returns {boolean} - true if the animation is currently running, false otherwise.\n */\n\n is_active(id) {\n    if(!this.lerp_registry.active_groups.has(this.lerp_registry.group.has(id)) || !this.lerp_registry.active_group_indices.get(this.lerp_registry.group.get(id)).has(id)){\n    type=this.lerp_registry.type[id]\n    switch(type){\n        case(2 | 3):\n        return this.lerp_registry.active_numbers.includes(id);\n        case(3):\n        return this.lerp_registry.active_matrices.has(id)\n    }\n} else {return this.lerp_registry.active_group_indices.get(this.lerp_registry.group.get(id)).has(id)}\n    \n}\n/**\n * Gets the current step of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current step value of the animation.\n */\n get_step(id) {\n    return this.sequence_registry.progress(id);\n}\n/**\n * Gets the lerp result value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The lerp result value of the animation.\n */\n\n get_lerp_value(id) {\n    type=this.lerp_registry.type[id]\n    group=this.lerp_registry.group.get(id)\n    if(!group || !this.lerp_registry.active_groups.has(id))\n    switch(type){\n        case(2):  return this.lerp_registry.number_results.get(id);\n        case(3): return this.lerp_registry.matrix_results.get(id)\n    }\n    else{\n        return this.lerp_registry.active_group_indices.get(group).has(id)\n    }\n    \n}\n/**\n * Starts and resets an animation if its finished, or not playing.\n * @param {number} id - The identifier for the animation.\n */\n soft_reset(id) {\n    this.sequence_registry.soft_reset(id);\n}\n/**\n * Starts and resets an animation.\n * @param {number} id - The identifier for the animation.\n */\n hard_reset(id) {\n    this.sequence_registry.reset(id);\n}\n/**\n * Sets the current progress of an animation and updates the delta t value accordingly.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The new progress value for the animation.\n */\n set_time(id, val) {\n    this.lerp_registry.progress = val;\n}\n/**\n * Sets the current step of an animation.\n * If the provided step value exceeds the maximum length of the animation, it will be set to the maximum length.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired step value for the animation.\n */\n\n set_step(id, val) {\n    this.sequence_registry.progress[id] =\n        val > this.sequence_registry.lengths[id] ? this.sequence_registry.lengths[id] : val;\n}\n\n set_sequence_start(id, val) {\n    this.lerp_registry.lerp_chain_start[id] = val;\n}\n get_sequence_start(id) {\n    return this.lerp_registry.lerp_chain_start[id];\n}\n set_sequence_length(id, val) {\n    this.sequence_registry.lengths[id] = val;\n}\n\n get_sequence_length(id) {\n    return this.sequence_registry.lengths[id];\n}\n/**\n * Retrieves the target value for a specific step of an animation.\n *\n * This  determines the type of the animation and returns the target value\n * for the specified step.\n *\n * @param {number} id - The identifier for the animation.\n * @param {number} step - The step for which to retrieve the target value.\n * @returns {number|number[]} - The target value for the specified step of the animation.\n */\n\n get_step_lerp_target_value(id, step) {\n    if (this.lerp_registry.type[id] == 2)\n        return this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[id] + step];\n    else if (this.lerp_registry.type[id] == 3)\n        return this.sequence_registry.matrix_sequences.get(id).get(step);\n}\n\n/**\n * Gets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The duration of the animation.\n */\n get_duration(id) {\n    return this.lerp_registry.duration[id];\n}\n/**\n * Sets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired duration value for the animation.\n */\n set_duration(id, val) {\n    this.lerp_registry.duration[id] = val;\n}\n/**\n * Retrieves the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The delay value of the animation.\n */\n\n get_delay(id) {\n    return this.lerp_registry.delay[id];\n}\n/**\n * Sets the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay value for the animation.\n */\n set_delay(id, val) {\n    this.lerp_registry.delay[id] = val;\n}\n\n/**\n * Retrieves the current delay progress value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current delay progress value of the animation.\n */\n get_delay_delta(id) {\n    return this.lerp_registry.delay_delta[id];\n}\n/**\n * Sets the current delay progress value for an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay progress value for the animation.\n */\n set_delay_delta(id, val) {\n    this.lerp_registry.delay_delta[id] = val;\n}\n\n/**\n * Retrieves a specific row from a matrix constant.\n * @param {number} id - The identifier for the matrix constant.\n * @param {number} row - The index of the row to retrieve from the matrix constant.\n * @returns {Array} - The specified row from the matrix constant.\n */\n get_constant_row(id, row) {\n    return this.constant_registry.get_row(id, row);\n}\n\n/**\n * Retrieves a constant number value by its identifier.\n * @param {number} id - The identifier for the constant number.\n * @returns {number} - The constant number value associated with the given identifier.\n */\n get_constant_number(id) {\n    return this.constant_registry.get_number(id);\n}\n/**\n * Retrieves an array of all active animation identifiers.\n * @returns {Array<number>} - An array of active animation identifiers.\n */\n get_active_group_indices(group){\n    return this.lerp_registry.active_groups.get(group)\n}\n get_active(type) {\n    switch(type){\n        case(2):\n            return this.lerp_registry.active_numbers\n        case(3):return this.lerp_registry.active_matrices;\n        case(4): return this.lerp_registry.active_timelines\n}\n}\n/**\n * Retrieves a boolean indicating whether the animation loop is currently running.\n * @returns {boolean} - true if the animation loop is currently running, false otherwise.\n */\n get_status() {\n    return this.loop_resolver != null;\n}\n\n/**\n * Replaces the target value for a specific step of an animation with a new one.\n *\n * If the animation type is not a matrix-chain, the  will set the lerp values\n * at the specified step and step + direction accordingly.\n *\n * If the animation type is a matrix-chain, the  will set the matrix values\n * at the specified step and step + direction accordingly.\n *\n * @param {object} opts - An object containing the following properties:\n * @param {number} opts.index - The index of the animation to reorient.\n * @param {number} opts.step - The step for which to reorient the target value.\n * @param {number} opts.direction - The direction (+1 or -1) in which to reorient the target value.\n * @param {number|number[]} opts.reference - The new target value to set for the animation.\n * @param {number[]} opts.matrix_row - The matrix row to set as the new target value.\n * @param {boolean} opts.verbose - Whether to log information about the reorientation process.\n */\n reorient_target({\n    index,\n    step=0,\n    direction=1,\n    reference,\n    matrix_row = 0,\n    start_reference,\n    verbose = false,\n\n}) {\n    verbose && console.log(\"replacing indices \" + index);\n    if (this.lerp_registry.type[index] != 2) {\n        if(start_reference){\n            this.setMatrix(index, step, start_reference);\n        }\n        else{\n            this.setMatrix(index, step, this.get_lerp_value(index));\n        }\n        this.setMatrix(index, step + direction, reference, matrix_row);\n    } else {\n        this.setLerp(index, step, reference);\n        this.setLerp(index, step + direction, matrix_row);\n    }\n//    verbose && console.log(\"reoriented animation with index \" + index);\n}\n\n/**\n * Reorients the duration of an animation.\n *\n * If min_duration is given, the  will soft_reset the animation and set its duration to the minimum of max_duration and max_duration - current_time + min_duration.\n *\n * @param {object} opts - An object containing the following properties:\n * @param {number} opts.index - The index of the animation to reorient.\n * @param {number} opts.min_duration - The minimum duration of the animation.\n * @param {number} opts.max_duration - The maximum duration of the animation.\n * @param {boolean} opts.verbose - Whether to log information about the reorientation process.\n */\n reorient_duration({\n    index,\n    min_duration,\n    max_duration,\n    verbose = false,\n}) {\n    if (min_duration != undefined) {\n        this.soft_reset(index);\n        const time = this.is_active(index) ? this.get_time(index) : 0;\n        const duration =\n            time < min_duration ? Math.floor(max_duration - time) : max_duration;\n        this.set_duration(index, duration);\n        verbose &&\n            console.log(\"new start_duration for \" + index + \" is \" + duration);\n    }\n}\n/**\n * Linearly interpolates between two values.\n *\n * @param {number} value - The current value of the animation.\n * @param {number} target - The target value of the animation.\n * @param {number} min - The minimum value of the animation.\n * @param {number} max - The maximum value of the animation.\n * @param {number} threshold - The value to return if the interpolation would result in a value less than this.\n * @returns {number} The interpolated value.\n */\n lerp(value, target, min, max, threshold) {\n    const t = (value - min) / (max - min);\n    const result = target * t + (1 - t) * threshold;\n    return result;\n}\n/**\n * Normalizes a distance between two values to a value between 0 and 1.\n * @param {number} target - The target value.\n * @param {number} current - The current value.\n * @param {number} max - The maximum value.\n * @returns {number} - The normalized distance.\n */\n normalizeDistance(target, current, max) {\n    const distance = Math.abs(current - target);\n    return distance / Math.abs(max - target);\n}\n/**\n * Clamps a value to a minimum and maximum value.\n *\n * @param {number} value - The value to clamp.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The clamped value.\n */\n clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Reorients the duration of an animation based on the distance between the current value\n * and a target value.\n *\n * @param {object} opts - An object containing the following properties:\n * @param {number} opts.index - The index of the animation to reorient.\n * @param {number|number[]} opts.target - The target value towards which to reorient the animation.\n * @param {number} opts.max_distance - The max distance.\n * @param {number} opts.min_duration - The minimum duration of the animation.\n * @param {number} opts.max_duration - The maximum duration of the animation.\n * @param {string} opts.mode - The mode to use for calculating the distance. Possible values are \"max_distance\",\n *                             \"manhattan_distance\", \"cosine_similarity\", and \"vector_magnitude\".\n *\n * @returns {object} - {duration,differences}\n */\n reorient_duration_by_distance({\n    index,\n    target,\n    max_distance,\n    min_duration,\n    max_duration,\n    mode = \"max_distance\",\n    reorientate_steps=false\n}) {\n    const current = this.get_lerp_value(index);\n\n    if (this.lerp_registry.type[index] != 2) {\n        var dif\n        switch (mode) {\n            case \"max_distance\":\n                const distances = [];\n                dif=[]\n                for (let i = 0; i < target.length; i++) {\n                    distances.push(Math.abs(target[i] - current[i]));\n                    dif.push(target[i] - current[i])\n                }\n                distance = Math.max(...distances);\n                \n                break;\n            case \"manhattan_distance\":\n                distance = 0;\n                dif=[]\n                for (let i = 0; i < target.length; i++) {\n                    distance += Math.abs(target[i] - current[i]);\n                    dif.push(target[i] - current[i])\n                }\n                break;\n            case \"cosine_similarity\":\n                const dotProduct = 0;\n                const magnitudeTarget = 0;\n                const magnitudeCurrent = 0;\n                dif=[]\n                for (let i = 0; i < target.length; i++) {\n                    dotProduct += target[i] * current[i];\n                    dif.push(target[i] - current[i])\n                    magnitudeTarget += target[i] ** 2;\n                    magnitudeCurrent += current[i] ** 2;\n                }\n                magnitudeTarget = Math.sqrt(magnitudeTarget);\n                magnitudeCurrent = Math.sqrt(magnitudeCurrent);\n                distance = 1 - dotProduct / (magnitudeTarget * magnitudeCurrent);\n                break;\n            case \"vector_magnitude\":\n                distance = 0;\n                dif=[]\n                for (let i = 0; i < target.length; i++) {\n                    distance += (target[i] - current[i]) ** 2;\n                    dif.push((target[i] - current[i]))\n                }\n                distance = Math.sqrt(distance);\n                break;\n            default:\n                throw new Error(`Unbekannter Modus: ${mode}`);\n        }\n    } else if (this.lerp_registry.type[index] == 2)\n        distance = Math.abs(target - max_distance);\n    duration =\n        min_duration + (distance / max_distance) * (max_duration - min_duration);\n    //Math.min(max_duration, Math.max(min_duration, distance * max_distance));\n    this.soft_reset(index);\n    this.set_duration(index, duration);\n    return {\n        duration:duration,\n        diffrences:dif\n    };\n}\n reorient_duration_by_progress({ index, min_duration, max_duration,soft_reset=true }) {\n    const progress = this.get_time(index) / max_duration;\n\n    duration = min_duration + progress * (max_duration - min_duration);\n    //Math.min(max_duration, Math.max(min_duration, distance * max_distance));\n    if(soft_reset){\n        this.soft_reset(index);\n    }\n    else{\n        \n    }\n    this.set_duration(index, duration);\n    return duration;\n}\n/**\n * Reverses the order of the lerp or matrix values in the animation sequence.\n *\n * @param {number|string} id - The identifier for the animation or the lerp-chain to reverse.\n *\n * @category Animation\n */\n reverse(id) {\n    if (type(id) != \"number\") {\n        for (\n            let i = this.lerp_registry.lerp_chain_start[id];\n            i <= this.lerp_registry.lerp_chain_start[id] + this.sequence_registry.lengths[id];\n            i++\n        ) {\n            this.sequence_registry.buffer[this.sequence_registry.lengths[id] - i] =\n                this.sequence_registry.buffer[i];\n        }\n    } else {\n        const newMap = new Map();\n        this.sequence_registry.matrix_sequences.get(id).forEach((val, i) => {\n            newMap.set(this.sequence_registry.lengths[id] - i, val);\n        });\n        this.sequence_registry.matrix_sequences.set(id, newMap);\n    }\n}\nreverse_group_delays(id){\n    this.matrix_chain_registry.indices.get(id).map((val,i)=>{\n        // if(i==this.matrix_chain_registry.indices.get(id).length-1){\n        //     return\n        // }\n        const target_index=this.matrix_chain_registry.indices.get(id).length-i\n        const target=this.matrix_chain_registry.indices.get(id)[target_index-1]\n        const target_delay=this.get_delay(target)\n        this.set_delay(target,this.get_delay(val))\n        this.set_delay(val,target_delay)\n    })\n}\nset_group_orientation(id,orientation){  \n    this.matrix_chain_registry.orientation_step.set(id,orientation)\n}\n    /**\n * Starts an animation sequence for a matrix chain.\n *\n * @param {number[]} directions - The directions for the animation sequence.\n * @param {number[]} indices - The indices for the animation sequence.\n * @param {number[] | false} reorient - [start,target] | false if you ont want to set the current lerp value as the new start value\n * otherwise the matrix animation wont be set\n * @category Animation\n */\nstart_group(directions, indices,reorient) {\n    indices.map((indices2,i)=>{\n        if(!this.lerp_registry.active_groups.has(i)){\n        this.matrix_chain_registry.start_matrix_chain(directions[i],indices2,reorient)\n        }\n        // this.start_animations(this.matrix_chain_registry.indices.get(indices2))\n    })\n    this.start_loop();\n}\n/**\n * Resets all animations of a group.\n * You can optionally reorientate the group during the reset if you pass a reference.\n *\n * @param {number} id - The identifier of the group to reset.\n * @param {Array} start - the target reference to use for the start value\n * @param {number} target - The target reference index to use during the reset.\n */\n\nreset_group(id,start,target){\n    this.matrix_chain_registry.reset_group(id,start,target)\n    \n}\nstop_group(indices) {\n    if(indices==\"all\"){\n        \n        indices=[...this.lerp_registry.active_groups]\n    }\n    indices.map((id,i)=>{\n    if(this.lerp_registry.active_groups.has(id)){\n        this.lerp_registry.active_groups.delete(id)\n        this.lerp_registry.active_group_indices.get(id).clear() \n        this.matrix_chain_registry.progress[id]=0\n        this.stop_animations(this.matrix_chain_registry.indices.get(id))\n    }\n\n    })\n}\nget_group_values(id){\n    return{\n        active:this.lerp_registry.active_groups.has(id),\n        progress:this.matrix_chain_registry.progress[id],\n        orientation:this.matrix_chain_registry.orientation_step.get(id),\n        active_indices:this.lerp_registry.active_group_indices.get(id),\n        loop:this.matrix_chain_registry.group_loop[id]\n    }\n}\nset_group_values(id,field,value,step){\n    switch(field){\n        case \"max_duration\":\n            this.matrix_chain_registry.max_duration[id]=value\n            break;\n        case \"min_duration\":\n            this.matrix_chain_registry.min_duration[id]=value\n            break;\n        case \"progress\":\n            this.matrix_chain_registry.progress[id]=value\n            break;\n        case \"sequence_length\":\n            this.matrix_chain_registry.sequence_length[id]=value\n            break;\n        case \"group_loop\":\n            this.matrix_chain_registry.group_loop[id]=value\n        case \"orientation_step\":\n            this.matrix_chain_registry.orientation_step.set(id,value)\n            break;\n        case \"ref_matrix\":\n            if(this.matrix_chain_registry.uni_size[id]==1){\n                this.matrix_chain_registry.ref_matrix.get(id).get(step).map((x,i)=>{\n                    this.matrix_chain_registry.ref_matrix.get(id).get(step)[i]=value[i]\n                })\n                }\n            else{\n                const size=this.matrix_chain_registry.max_length[id]\n                this.matrix_chain_registry.ref_matrix.get(id).set(id*size+step).map((x,i)=>x=   value[i])\n            }\n            \n            break;\n    }\n}\n}\nexport{\nWorker_Utils\n}\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Copyright (c) 2025 Ji-Podhead and Project Contributors\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n// 1. All commercial uses of the Software must:\n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).\n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nimport { Worker_Utils } from \"kooljs/worker_utils\";\nvar triggers_step, animator, active_index, triggers_step\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp extends Worker_Utils {\n    constructor(results, callback_map, type, duration, render_interval, delay, delay_delta, progress, smoothstep, lerp_chain_start, loop, group, group_lookup, lerp_callback_ids) {\n        super()\n        this.type = type\n        this.duration = duration\n        this.matrix_chain_groups = undefined\n        this.render_interval = render_interval\n        this.delay_delta = delay_delta\n        this.delay = delay\n        this.progress = progress\n        this.smoothstep = smoothstep\n        this.matrix_chain_registry = undefined\n        this.lerp_chain_start = lerp_chain_start\n        this.loop = loop\n        this.group = group\n        this.group_lookup = group_lookup\n        this.active_groups = new Set()\n        this.active_group_indices = new Map()\n        this.active_timelines = new Set()\n        this.active_matrices = new Set()\n        this.active_numbers = []\n        this.active_group_indices_render = new Map()\n        this.group_results_render = new Map()\n        this.matrix_results_render = new Map()\n        this.number_results_render = new Map()\n        this.matrix_results = results.get(\"matrix_results\")\n        this.number_results = results.get(\"number_results\")\n        this.group_results = new Map()\n        this.lerp_callbacks = new Map();\n        this.loop_resolver = null;\n        lerp_callback_ids.forEach((val, key) => {\n            // no shallow copy just copying the pointer\n            this.lerp_callbacks.set(key, callback_map.get(val));\n        });\n    }\n    activate(id) {\n        switch (this.type[id]) {\n            case (2):\n                if (this.active_numbers.includes(id) == false) {\n                    this.active_numbers = Uint8Array.from([...this.active_numbers, id])\n                    this.number_results_render.delete(id)\n                    return false\n                }\n                else {\n                    return true\n                }\n            case (3):\n                //if(this.group.has(id)!=true){\n                if (this.active_matrices.has(id) == false) {\n                    this.active_matrices.add(id)\n                    this.matrix_results_render.set(id, new Map())\n\n                    return false\n                }\n                else {\n                    return true\n                }\n            case (4):\n                if (this.active_timelines.has(id) == false) {\n                    this.active_timelines.add(id)\n                    return false\n                }\n                else {\n                    return true\n                }\n        }\n    }\n    delete_group_member(id) {\n        if (this.group.has(id)) {\n            const group = this.group.get(id)\n            if (this.active_groups.has(group)) {\n                this.active_group_indices.get(group).delete(id)\n                this.group_results_render.get(group).delete(this.group_lookup.get(id))\n                if (this.active_group_indices.get(group).size == 0) {\n                    this.matrix_chain_registry.update_group(group)\n                }\n                return true\n            }\n            return false\n        }\n        else { return false }\n    }\n    deactivate(id) {\n        switch (this.type[id]) {\n            case (3):\n                if (this.delete_group_member(id) == false) {\n                    this.active_matrices.delete(id);\n                    this.matrix_results_render.delete(id);\n                }\n                break\n            case (2):\n                active_index = this.active_numbers.indexOf(id)\n                this.active_numbers = Uint8Array.from([...this.active_numbers.slice(0, active_index), ...this.active_numbers.slice(active_index + 1, this.active_numbers.length)])\n                this.number_results_render.delete(id)\n\n                break\n            case (4):\n                this.active_timelines.delete(id);\n        }\n    }\n    stop_all() {\n        this.active_numbers = []\n        this.active_matrices.clear()\n        this.active_timelines.clear()\n        this.active_groups.clear()\n        this.active_groups.forEach((val, key) => {\n            this.active_group_indices.get(key).clear()\n        })\n        this.group_results_render.clear()\n        this.matrix_results_render.clear()\n        this.number_results_render.clear()\n        // this.active_group_indices.forEach((val, key) => {\n        //     this.active_group_indices.set(key, [])\n        // })\n    }\n}\nconst default_target_step = [0, 1]\nvar final_step, final_sub_step;\nclass LerpSequence extends Worker_Utils {\n    /**\n     * The constructor for the LerpChain class.\n     * Initializes properties related to the state and progress of the lerp chain.\n     *\n     * @property {Array|undefined} buffer - The buffer holding the chain data.\n     * @property {Map|undefined} matrixChains - The map containing matrix chains.\n     * @property {Array|undefined} progress - The progress of each chain.\n     * @property {Array|undefined} lengths - The lengths of each chain.\n     */\n    constructor(buffer, matrix_sequences, progress, lengths, animator) {\n        super()\n        this.buffer = buffer\n        this.matrix_sequences = matrix_sequences\n        this.progress = progress\n        this.lengths = lengths\n        this.lerp_registry = animator.lerp_registry\n    }\n    update_progress(id) {\n        if (this.progress[id] == this.lengths[id] - 1) {\n            this.stop_animations([id])\n        } else {\n            this.reset_and_update(id);\n            return false;\n        }\n    }\n    reset_and_update(id) {\n        this.lerp_registry.delay_delta[id] = 0;\n        this.lerp_registry.progress[id] = 0;\n        this.progress[id] += 1;\n    }\n    reset(id) {\n        switch (this.lerp_registry.type[id]) {\n            case (2):\n                this.lerp_registry.number_results[id] = this.buffer[this.lerp_registry.lerp_chain_start[id]]\n                break\n            case (3):\n                if (!this.lerp_registry.group.get(id))\n                    this.lerp_registry.matrix_results.set(\n                        id,\n                        this.matrix_sequences.get(id).get(0)\n                    );\n                break\n        }\n        this.lerp_registry.delay_delta[id] = 0;\n        this.lerp_registry.progress[id] = 0;\n        this.progress[id] = 0;\n    }\n    soft_reset(id) {\n        if (this.lerp_registry.activate(id) == false) {\n            final_step = this.progress[id] == this.lengths[id] - 1;\n            final_sub_step = this.lerp_registry.progress[id] >= this.lerp_registry.duration[id];\n            if (final_step && final_sub_step) {\n                this.reset(id);\n            } else if (final_sub_step) {\n                this.reset_and_update(id);\n            }\n        }\n    }\n}\nvar indices\nclass Matrix_Chain extends Worker_Utils {\n    constructor(indices, ref_matrix, uni_size,orientation_step, max_duration, min_duration, custom_delay,  group_loop, max_length, sequence_length, animator) {\n        super()\n        this.indices = indices;\n        this.ref_matrix = ref_matrix;\n        this.orientation_step = orientation_step\n        this.max_duration = max_duration;\n        this.min_duration = min_duration;\n        this.uni_size=uni_size\n        this.max_length = max_length\n        this.custom_delay = custom_delay;\n        this.progress = new Uint8Array(indices.size).fill(0, 0, indices.length)\n        this.sequence_length = sequence_length\n        this.lerp_registry = animator.lerp_registry\n        this.group_loop = group_loop\n        this.sequence_registry = animator.sequence_registry\n        this.constant_registry = animator.constant_registry\n        this.lerp_registry = animator.lerp_registry\n        this.start_loop = animator.start_loop\n        this.callback_map = animator.callback_map\n        this.result_map = new Map()\n        indices.forEach((val, i) => {\n            this.lerp_registry.active_group_indices.set(i, new Set())\n            this.lerp_registry.group_results.set(i, new Map())\n            val.map((group, i2) => {\n                this.lerp_registry.group_results.get(i).set(i2, ref_matrix.get(i).get(i2))\n            })\n        })\n    }\n    reorient_matrix_chain({ id, target_step, direction,reorientate }) {\n        var indices = this.indices.get(id)\n        indices.map((index, i) => {\n            var ref = this.ref_matrix.get(id)\n            var start_ref\n            const current = this.get_lerp_value(index);\n            var base\n            if(this.uni_size[id]==1){\n                base=0\n            }\n            else{\n                base = i * this.max_length[id]\n            }\n            this.lerp_registry.active_group_indices.get(id).add(index)\n            if (reorientate!=\"progress\")  {\n                start_ref = ref.get(target_step[direction==1?0:1] + base);\n            }\n            ref = ref.get(target_step[direction] + base);\n            if (ref == current) {\n                return console.log(\"target animation is reachead\");\n            }\n            this.hard_reset(index);\n            if(reorientate)this.reorient_target({\n                index: index,\n                step: 0, // this is alway zero, since the matrix itself has a steplength of 2, but the ref matrix lnegth can be bigger\n                direction: 1,\n                matrix_row: 0,\n                verbose: false,\n                reference: ref,\n                start_reference: start_ref\n\n            });\n            if (this.custom_delay[id] !=255) {\n                const delay = (this.lambda_call(this.custom_delay[id], { animation_index: index, index: i, indices: indices, progress:this.progress[id],direction: direction, target_step: target_step }) || 0)\n                this.set_delay(index, delay);\n            }\n            if(reorientate==\"progress\")this.reorient_duration_by_progress({\n                index: index,\n                min_duration: this.min_duration[id],\n                max_duration: this.max_duration[id],\n                soft_reset: false\n            });\n        });\n    }\n    /**\n     * Resets a group of animations.\n     * @param {number} id - The id of the group.\n     */\n    reset_group(id,start,target){ \n                if(start!=undefined){\n                    if (start==target|| this.ref_matrix.get(id).get(start)==undefined || this.ref_matrix.get(id).get(target)==undefined) {\n                        return console.log(\"start or target is not valie\");\n                    }\n                    var indices = this.indices.get(id)\n                        indices.map((index, i) => {\n                            var target_ref = this.ref_matrix.get(id)\n                            var start_ref\n                            var base\n                            if(this.uni_size[id]==1){\n                                base=0\n                            }\n                            else{base = i * this.max_length[id]}\n                            start_ref = target_ref.get(start + base);\n                            target_ref = target_ref.get(target + base);\n\n                            this.hard_reset(index);\n                            this.setMatrix(index, 0, start_ref);\n                            this.setMatrix(index, 1, target_ref);\n                        });\n                    \n                }else{\n                    indices.map((index, i) => {\n                    this.hard_reset(index);\n                    })\n                }\n    }\n    start_matrix_chain(direction, id,reorientate=\"progress\") {\n        this.result_map.clear()\n        const target= this.orientation_step.get(id)// ? this.orientation_step.get(id) : default_target_step[direction == 0 ? 1 : 0]\n        this.lerp_registry.group_results_render.set(id, this.result_map)\n        //this.lerp_registry.active_group_indices_render.set(id,this.lerp_registry.active_group_indices.get(id))\n        this.reorient_matrix_chain({\n            id: id,\n            direction: direction,\n            target_step: target,\n            reorientate:reorientate,\n        })\n        this.lerp_registry.active_groups.add(id)\n    }\n    group_set( id) {\n        // this.progress.set(id,progress)\n        \n        const ref = this.ref_matrix.get(id)\n        this.indices.get(id).map((index, i) => {\n            var base\n            if(this.uni_size[id]==1){\n                base=0\n            }\n            else{\n                base = i * this.max_length[id]\n            }\n            const start_index = base + this.progress[id]\n            const end_index = base + this.progress[id] + 1\n            const start = ref.get(start_index)\n            const end = ref.get(end_index)\n\n            this.setMatrix(index, 0, start)\n            this.setMatrix(index, 1, end)\n            this.lerp_registry.active_group_indices.get(id).add(index)\n            this.hard_reset(index)\n        })\n        \n    }\n    update_group(id) {\n        this.progress[id] += 1\n        if (this.progress[id] >= this.sequence_length[id]) {\n            this.progress[id] = 0\n            if (this.group_loop[id] == 1) {\n                this.orientation_step.set(id, [0, 1])\n                if (this.sequence_length[id] == 1) {\n                    this.start_matrix_chain(1, id,true)\n                }\n                else {\n                    this.group_set(id)\n                }\n            }\n            else {\n                this.lerp_registry.active_groups.delete(id)\n            }\n        }\n        else {\n             this.group_set(id)\n        }\n    }\n}\nclass Constant extends Worker_Utils {\n    constructor(constants, animator) {\n        super()\n        this.reg = new Map()\n        this.reg.set(\"matrix\", new Map())\n        this.reg.set(\"number\", undefined)\n        this.render_triggers = new Map();\n        this.render_callbacks = new Map();\n        this.animator = animator\n        if (constants.get(\"matrix\") != undefined) {\n            constants.get(\"matrix\").forEach((val, i) => {\n                this.reg.get(\"matrix\").set(i, new Map());\n                val.map((m, i2) => {\n                    this.reg.get(\"matrix\").get(i).set(i2, new Float32Array(m));\n                });\n            });\n        }\n        if (constants.get(\"number\") != undefined) {\n            this.reg.set(\"number\", constants.get(\"number\"))\n        }\n        this.render_triggers = constants.get(\"render_triggers\");\n        this.render_callbacks = constants.get(\"render_callbacks\");\n    }\n    update(type, id, value) {\n        //[\"matrix\",\"number\"].includes[\"type\"]&&this.reg.get(type).has(id)&&\n        this.reg.get(type).set(id, value);\n        if (this.render_callbacks.has(id))\n            this.render_callbacks.get(id).map((l) => {\n                this.animator.callback_map.get(l.id)(l.args);\n            });\n        if (this.render_triggers.has(id))\n            this.animator.start_animations(this.render_triggers.get(id));\n    }\n    get(type, index, row) {\n        if (row != undefined) {\n            this.get_row(index, row);\n        } else return this.reg.get(type).get(index);\n    }\n    get_row(index, row) {\n        return this.reg.get(\"matrix\").get(index).get(row);\n    }\n    get_number(index) {\n        return this.reg.get(\"number\").get(index);\n    }\n}\n// ----------------------------------------> ANIMATION <--\nvar t;\nvar targets, allow_render, args, delta_t, res\nvar startTime, timeoutId\nvar indices, buffer\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v);\n    //  t=(t*amount)/t\n    return max * t + min * (1 - t);\n}\nfunction smoothstep(x) { return x * x * (3 - 2 * x) }\nclass Animator extends Worker_Utils {\n    constructor(new_fps, lerps, lerpChains, results, triggers, constants, condi_new, matrix_chains, springs) {\n        super()\n        this.fps = new_fps;\n        // this.buffer = buffer.transfer(buffer.byteLength);\n        // this.result_buffer = result_buffer;\n        this.callback_map = new Map();\n        this.trigger_registry = new Map();\n        this.callback_map = new Map();\n        this.update_group = undefined\n        triggers.forEach((trigger, key) => this.trigger_registry.set(key, trigger));\n        condi_new.forEach((val, key) => {\n            try {\n                this.callback_map.set(key, eval(val));\n            } catch (err) {\n                console.error(\n                    \"failed to eval callback function on the worker for: \" + key\n                );\n                console.error(val);\n                console.error(err);\n            }\n        });\n        this.lerp_registry = new Lerp(\n            results,\n            this.callback_map,\n            lerps.get(\"type\"),\n            lerps.get(\"duration\"),\n            lerps.get(\"render_interval\"),\n            lerps.get(\"delay\"),\n            lerps.get(\"delay_delta\"),\n            lerps.get(\"progress\"),\n            lerps.get(\"smoothstep\"),\n            lerps.get(\"lerp_chain_start\"),\n            lerps.get(\"loop\"),\n            lerps.get(\"group\"),\n            lerps.get(\"group_lookup\"),\n            lerps.get(\"lerp_callbacks\"),\n            this\n        )\n        this.sequence_registry = new LerpSequence(\n            lerpChains.get(\"buffer\"),\n            lerpChains.get(\"matrix_buffer\"),\n            lerpChains.get(\"progress\"),\n            lerpChains.get(\"lengths\"),\n            this\n        )\n        this.matrix_chain_registry = new Matrix_Chain(\n            matrix_chains.get(\"indices\"),\n            matrix_chains.get(\"ref_matrix\"),\n            matrix_chains.get(\"uni_size\"),\n            matrix_chains.get(\"orientation_step\"),\n            matrix_chains.get(\"max_duration\"),\n            matrix_chains.get(\"min_duration\"),\n            matrix_chains.get(\"custom_delay\"),\n            matrix_chains.get(\"group_loop\"),\n            matrix_chains.get(\"max_length\"),\n            matrix_chains.get(\"sequence_length\"),\n            this\n        )\n        this.update_group = this.matrix_chain_registry.update_group\n        this.lerp_registry.matrix_chain_registry = this.matrix_chain_registry\n        this.start_matrix_chain = this.matrix_chain_registry.start_matrix_chain\n        this.lerp_registry.matrix_chain_registry = this.matrix_chain_registry\n\n        this.constant_registry = new Constant(constants, this)\n        this.animateLoop = async function () {\n            try {\n                this.loop_resolver = new AbortController();\n                this.loop_resolver.signal.addEventListener(\"abort\", () => {\n                    clearTimeout(timeoutId);\n                });\n                while (this.loop_resolver.signal.aborted == false) {\n                    startTime = performance.now();\n                    this.lerp_registry.active_timelines.forEach((id) => this.animate(id))\n                    this.lerp_registry.active_numbers.map((id, i) =>\n                        this.animate(id, this.animate_number, this.lerp_registry.number_results, 2, i))\n                    this.lerp_registry.active_matrices.forEach((id) => this.animate(id, this.animate_matrix, this.lerp_registry.matrix_results, 3))\n                    this.lerp_registry.active_groups.forEach((group_id) => {\n                        this.lerp_registry.active_group_indices.get(group_id).forEach((id, i) => { this.animate(id, this.animate_matrix, this.lerp_registry.matrix_results, 0, group_id, i) })\n                    })\n                    this.render();\n                    if (this.lerp_registry.active_groups.size > 0\n                        || this.lerp_registry.active_timelines.size > 0\n                        || this.lerp_registry.active_matrices.size > 0\n                        || this.lerp_registry.active_numbers.length > 0\n                    ) {\n                        await new Promise((resolve, reject) => {\n                            timeoutId = setTimeout(() => {\n                                resolve();\n                            }, Math.max(0, this.fps - (performance.now() - startTime)));\n                        });\n                    } else {\n                        return this.stop_loop();\n                    }\n                }\n            } catch {\n                (err) => {\n                    this.stop_loop();\n                    this.stop_animations(\"all\");\n                    return Error(\"had a error during animation. stoppingloop! \" + err);\n                };\n            }\n        }\n        this.animate_matrix = ((id, delta_t, target) => {\n            //lookup = this.lerp_registry.a.get(id) != undefined ? this.lerp_registry.group_lookup.get(id) : id\n            for (let i = 0; i < this.sequence_registry.matrix_sequences.get(id).get(this.sequence_registry.progress[id]).length; i++) {\n                target.get(id)[i] = smoothLerp(\n                    this.sequence_registry.matrix_sequences\n                        .get(id)\n                        .get(this.sequence_registry.progress[id])[i],\n                    this.sequence_registry.matrix_sequences\n                        .get(id)\n                        .get(this.sequence_registry.progress[id] + 1)[i],\n                    delta_t,\n                    this.lerp_registry.smoothstep[id]\n                );\n            }\n        })\n        this.animate_number = ((id, delta_t, target, render_index) => {\n            target[id] = smoothLerp(\n                this.sequence_registry.buffer[\n                this.lerp_registry.lerp_chain_start[id] +\n                this.sequence_registry.progress[id]\n                ],\n                this.sequence_registry.buffer[\n                this.lerp_registry.lerp_chain_start[id] +\n                this.sequence_registry.progress[id] +\n                1\n                ],\n                delta_t,\n                this.lerp_registry.smoothstep[id]\n            )\n            this.lerp_registry.number_results_render.set(id, target[id])\n\n        })\n        this.animate = async function (index, method, target, type, reference) {\n            if (this.lerp_registry.progress[index] <= this.lerp_registry.duration[index]) {\n                if (this.lerp_registry.delay_delta[index] < this.lerp_registry.delay[index] - 1) {\n                    this.lerp_registry.delay_delta[index] += 1;\n                }\n                else if (this.lerp_registry.delay_delta[index] == 0 || (this.lerp_registry.delay_delta[index] < this.lerp_registry.delay[index])) {\n                    this.lerp_registry.delay_delta[index] += 1;\n                    if (method != undefined) {\n                        switch (type) {\n                            case (0):\n                                this.lerp_registry.group_results_render.get(reference).set(this.lerp_registry.group_lookup.get(index), this.lerp_registry.matrix_results.get(index))\n                                break\n                            case (2):\n                                this.lerp_registry.number_results_render.set(index, this.lerp_registry.number_results[index])\n                                break;\n                            case (3):\n                                this.lerp_registry.matrix_results_render.set(index, this.lerp_registry.matrix_results.get(index))\n                                break\n                        }\n                    }\n                }\n                else {\n                    allow_render = this.lerp_registry.progress[index] % this.lerp_registry.render_interval[index];\n                    if (allow_render == 0) {\n                        delta_t = this.lerp_registry.progress[index] / this.lerp_registry.duration[index];\n                        if (method != undefined) res = method(index, delta_t, target, reference)\n                        args = {\n                            id: index,\n                            value: res,\n                            step: this.sequence_registry.progress[index],\n                            time: this.lerp_registry.progress[index],\n                            step: this.sequence_registry.progress[index],\n                        };\n                        if (this.lerp_registry.lerp_callbacks.has(index)) {\n                            try {\n                                this.lerp_registry.lerp_callbacks.get(index)(args);\n                            }\n                            catch (err) { console.error(`got Error calling lambda number: ${index} \nFunction: ${this.lerp_registry.lerp_callbacks.get(index)}\nargs: ${JSON.stringify(args)}\nerror: ${err}\n-------------\nstopping animator now!\n                                `)\n                                this.stop_animations(\"all\");\n                            }\n                        }\n                    }\n                    this.lerp_registry.progress[index] += 1;\n                    if (allow_render == 0) {\n                        triggers_step =\n                            this.trigger_registry.get(index) != undefined\n                                ? this.trigger_registry.get(index).get(this.sequence_registry.progress[index])\n                                : undefined;\n                        if (triggers_step != undefined) {\n                            targets = triggers_step.get(this.lerp_registry.progress[index] - 1);\n                            targets && targets.map((target) => {\n                                if (target == index) {\n                                     this.hard_reset(target); this.lerp_registry.number_results_render.delete }\n                                else this.soft_reset(target);\n\n                            });\n                        }\n                    }\n                }\n            }\n            else { this.sequence_registry.update_progress(index) }\n        }\n        this.render = () => {\n            postMessage(\n                {\n                    message: \"render\",\n                    number_results: this.lerp_registry.number_results_render,\n                    matrix_results: this.lerp_registry.matrix_results_render,\n                    group_results: this.lerp_registry.group_results_render,\n                },\n            )\n            //this.result_buffer = result_buffer.transfer(result_buffer.byteLength);\n        }\n    }\n}\nvar const_map_new;\nonmessage = (event) => {\n    switch (event.data.method) {\n        case \"init\":\n            animator = new Animator(\n                event.data.fps,\n                event.data.data,\n                event.data.chain_map,\n                event.data.results,\n                event.data.trigger_map,\n                event.data.constants,\n                event.data.callback_map,\n                event.data.matrix_chain_map,\n                event.data.spring_map\n            );\n            break;\n        case \"update\":\n            animator.update(event.data.type, event.data.data);\n            break;\n        case \"update_constant\":\n            if (event.data.type == \"matrix\") {\n                const_map_new = new Map();\n                event.data.value.map((val, i) => {\n                    if (typeof val != \"\") {\n                        event.data.value[i] = new Float32Array(val);\n                    }\n                    const_map_new.set(i, event.data.value[i]);\n                });\n                animator.constant_registry.update(event.data.type, event.data.id, const_map_new);\n            } else {\n                animator.constant_registry.update(\n                    event.data.type,\n                    event.data.id,\n                    event.data.value\n                );\n            }\n            break;\n        case \"start\":\n            animator.start_loop();\n            break;\n        case \"set_lambda\":\n            animator.callback_map.set(event.data.id, eval(event.data.callback));\n            break;\n        case \"stop\":\n            animator.stop_loop();\n            break;\n        case \"change_framerate\":\n            animator.change_framerate(event.data.fps_new);\n            break;\n        case \"lambda_call\":\n            animator.lambda_call(event.data.id, event.data.args);\n            break;\n        case \"start_animations\":\n            animator.start_animations(event.data.indices);\n            break;\n        case \"stop_animations\":\n            animator.stop_animations(event.data.indices);\n            break;\n        case \"start_groups\":\n            animator.start_group(event.data.directions, event.data.indices,event.data.reorientate,event.data.use_start_reference);\n            break;\n        case \"stop_groups\":\n            animator.stop_group(event.data.indices);\n            break;\n        case \"set_group_orientation\":\n            animator.set_group_orientation(event.data.index, event.data.orientation);\n            break;\n        case \"reset_animations\":\n            animator.reset_animations(event.data.indices);\n            break;\n        case \"set_group\":{\n            animator.set_group_values(event.data.id, event.data.field,  event.data.value,event.data.step);\n        }\n        case \"addTrigger\":\n            animator.addTrigger({\n                id: event.data.id,\n                target: event.data.target,\n                step: event.data.step,\n                time: event.data.time\n            }\n            );\n            break;\n        case \"removeTrigger\":\n            animator.removeTrigger({\n                id: event.data.id,\n                target: event.data.target,\n                step: event.data.step,\n                time: event.data.time\n            }\n            );\n            break;\n        default:\n            console.warn(\"no method selected during worker call\");\n            break;\n    }\n};\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\n\nclass Spring {\n    constructor(elements, duration, spring_tension, spring_whatever) {\n        this.elements = elements;\n        this.duration = duration;\n        this.spring_tension = spring_tension;\n    }\n}\n//dijkstra algo für matrix\nfunction shortest_path() { }\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn() { }\n//matrix and callback for lerp\nfunction convex_hull() { }\nfunction spring() { }\nexport {\n    Animator as animator, Lerp, Matrix_Chain, Constant, LerpSequence\n}\n\n// this has to commented out when creating the docs\n\n//t = callback_registry.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n// const eslapsed = performance.now() - startTime;\n// const waitTime = Math.max(0, fps - elapsed);\n// postMessage({\n//     message: \"finish\",\n//     results: this.lerp_registry.results,\n//     result_indices: this.lerp_registry.activelist\n// });\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: this.lerp_registry.results, result_indices: this.lerp_registry.activelist })\n// }\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n\n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n\n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n\n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n\n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n\n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n\n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n\n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n\n//   const animations = calculateSpringAnimation(matrix, params);\n"],"names":["type","trigger","newtriggers","group","distance","duration","Worker_Utils","addTrigger","_ref","id","target","step","time","undefined","this","trigger_registry","get","set","Map","Uint8Array","includes","Array","push","console","warn","removeTrigger","_ref2","targetId","indexOf","length","splice","log","update","values","map","x","sequence_registry","lengths","lerp_registry","loop","val","i","buffer","lerp_chain_start","matrix_sequences","reset","lambda_call","args","callback_map","err","error","start_loop","loop_resolver","animateLoop","stop_loop","abort","start_animations","indices","delete_group_member","soft_reset","stop_animations","stop_all","deactivate","active_numbers","active_timelines","size","active_matrices","active_groups","reset_animations","t","stopped","results","number_results","matrix_results","activate","postMessage","message","change_framerate","fps_new","fps","render_constant","value","get_constant","setLerp","index","setMatrix","update_constant","constant_registry","get_time","progress","is_active","has","active_group_indices","get_step","get_lerp_value","hard_reset","set_time","set_step","set_sequence_start","get_sequence_start","set_sequence_length","get_sequence_length","get_step_lerp_target_value","get_duration","set_duration","get_delay","delay","set_delay","get_delay_delta","delay_delta","set_delay_delta","get_constant_row","row","get_row","get_constant_number","get_number","get_active_group_indices","get_active","get_status","reorient_target","_ref3","direction","reference","matrix_row","start_reference","verbose","reorient_duration","_ref4","min_duration","max_duration","Math","floor","lerp","min","max","threshold","normalizeDistance","current","abs","clamp","reorient_duration_by_distance","_ref5","max_distance","mode","reorientate_steps","dif","distances","dotProduct","magnitudeTarget","magnitudeCurrent","sqrt","Error","diffrences","reorient_duration_by_progress","_ref6","reverse","newMap","forEach","reverse_group_delays","matrix_chain_registry","target_index","target_delay","set_group_orientation","orientation","orientation_step","start_group","directions","reorient","indices2","start_matrix_chain","reset_group","start","stop_group","delete","clear","get_group_values","active","active_indices","group_loop","set_group_values","field","sequence_length","uni_size","ref_matrix","max_length","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","triggers_step","animator","active_index","Lerp","constructor","render_interval","smoothstep","group_lookup","lerp_callback_ids","super","matrix_chain_groups","Set","active_group_indices_render","group_results_render","matrix_results_render","number_results_render","group_results","lerp_callbacks","from","add","update_group","slice","default_target_step","final_step","final_sub_step","targets","allow_render","delta_t","res","startTime","timeoutId","const_map_new","LerpSequence","update_progress","reset_and_update","Matrix_Chain","custom_delay","fill","result_map","i2","reorient_matrix_chain","target_step","reorientate","start_ref","ref","base","animation_index","target_ref","arguments","group_set","start_index","end_index","end","Constant","constants","reg","render_triggers","render_callbacks","m","Float32Array","l","smoothLerp","v","amount","Animator","new_fps","lerps","lerpChains","triggers","condi_new","matrix_chains","springs","eval","async","AbortController","signal","addEventListener","clearTimeout","aborted","performance","now","animate","animate_number","animate_matrix","group_id","render","Promise","resolve","reject","setTimeout","render_index","method","JSON","stringify","onmessage","event","data","chain_map","trigger_map","matrix_chain_map","spring_map","callback","use_start_reference","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}